// cuboids.magma
// 
// Computations with the surface of the "rational box" problem
//
// Michael Stoll, started 2008-04-05

// Set quick to false to also perform the computations that take more time.
if not assigned quick then
  quick := true;
end if;

// Set up the ground field L = Q(i, sqrt(2)) ...
printf "Setting up ground field L, projective space and the surface S...\n";
L<i,s> := ext<Rationals() | Polynomial([1,0,1]), Polynomial([-2,0,1])>;
// ... and the ambient projective space
Pr6<a1,a2,a3,b1,b2,b3,c> := ProjectiveSpace(L, 6);

// The defining equations of the surface S
eqns := [a1^2 + a2^2 - b3^2, a2^2 + a3^2 - b1^2, a1^2 + a3^2 - b2^2, a1^2 + a2^2 + a3^2 - c^2];

// Define the surface S-bar.
S := Scheme(Pr6, eqns);

// The 48 singular points (see Lemma 3)
pts := Points(SingularSubscheme(S));
assert #pts eq 48;

// See Definition 6 for C1s, C2s, C3s.
printf "Constructing the known curves on S...\n";
// The a conics
C1s :=    [Curve(S, [a1, a2+e1*b3, a3+e2*b2, b1+e3*c]) : e1,e2,e3 in [1,-1]]
      cat [Curve(S, [a2, a3+e1*b1, a1+e2*b3, b2+e3*c]) : e1,e2,e3 in [1,-1]]
      cat [Curve(S, [a3, a1+e1*b2, a2+e2*b1, b3+e3*c]) : e1,e2,e3 in [1,-1]]
      cat [Curve(S, [c, i*a1+e1*b1, i*a2+e2*b2, i*a3+e3*b3]) : e3,e2,e1 in [1,-1]];

// The b curves
C2s :=    [Curve(S, [b1, i*a2+e1*a3, a1+e2*c]) : e1,e2 in [1,-1]]
      cat [Curve(S, [b2, i*a3+e1*a1, a2+e2*c]) : e1,e2 in [1,-1]]
      cat [Curve(S, [b3, i*a1+e1*a2, a3+e2*c]) : e1,e2 in [1,-1]];

// The other genus 1 curves
C3s :=    [Curve(S, [a1+e1*a2, s*a1+e2*b3, b1+e3*b2]) : e1,e2,e3 in [1,-1]]
      cat [Curve(S, [a2+e1*a3, s*a2+e2*b1, b2+e3*b3]) : e1,e2,e3 in [1,-1]]
      cat [Curve(S, [a3+e1*a1, s*a3+e2*b2, b3+e3*b1]) : e1,e2,e3 in [1,-1]]
      cat [Curve(S, [i*a1+e1*c, i*b2+e2*b3, i*s*a1+e3*b1]) : e3,e2,e1 in [1,-1]]
      cat [Curve(S, [i*a2+e1*c, i*b3+e2*b1, i*s*a2+e3*b2]) : e3,e2,e1 in [1,-1]]
      cat [Curve(S, [i*a3+e1*c, i*b1+e2*b2, i*s*a3+e3*b3]) : e3,e2,e1 in [1,-1]];

// All the curves...
Cs := C1s cat C2s cat C3s;
// ...and the singular points on them
Cpts := [{pt : pt in pts | pt in C} : C in Cs];

// Genus 3 hyperelliptic curves of degree 8
C4s :=    [Curve(ReducedSubscheme(Scheme(S, [b1+e2*b2+e3*b3, a2*a3+e1*i*a1*b1])))
            : e1,e2,e3 in [1,-1]]
      cat [Curve(ReducedSubscheme(Scheme(S, [b1+e2*i*b2+e3*b3, a1*a3+e1*b2*c])))
            : e1,e2,e3 in [1,-1]]
      cat [Curve(ReducedSubscheme(Scheme(S, [b1+e2*b2+e3*i*b3, a1*a2+e1*b3*c])))
            : e1,e2,e3 in [1,-1]]
      cat [Curve(ReducedSubscheme(Scheme(S, [b1+e2*i*b2+e3*i*b3, a2*a3+e1*b1*c])))
            : e1,e2,e3 in [1,-1]];

// Genus 3 nonhyperelliptic curves of degree 8
C5s :=    [Curve(ReducedSubscheme(Scheme(S, [a1+e2*a2+e3*a3+e4*i*c, (e2*a2+e3*a3)*b1+e1*i*b2*b3])))
            : e1,e2,e3,e4 in [1,-1]];

// Set up the intersection pairing
function intersection(C, j)
  // j is index in "Cs cat pts"
  if j le #Cs then
    m := 0;
    CC := C meet Cs[j];
    if Dimension(CC) eq 1 then
      // Cs[j] is contained in C; find the multiplicity m
      while IsSubscheme(Cs[j], C) do
        m +:= 1;
        C := Difference(C, Cs[j]);
      end while;
      CC := C meet Cs[j];
      assert Dimension(CC) lt 1;
    end if;
    // The self-intersection of Cs[j] is -4 --> -4*m
    // The count of intersection points (with multiplicity) --> Degree(CC)
    // Subtract the number of singularities of S-bar among these
    //   (blowing them up reduces the intersection number there) --> -&+[...]
    return -4*m + Degree(CC) - &+[Integers() | Multiplicity(C, pt) : pt in Cpts[j] | pt in C];
  else
    pt := pts[j-#Cs];
    return pt in C select Multiplicity(C, pt) else 0;
  end if;
end function;

// The pairing matrix;
// we take the curves first, then the exceptional divisors (represented by the singularities)
printf "Computing the intersection matrix...\n";
bdim := #Cs + #pts;
pairingmat := ZeroMatrix(Integers(), bdim, bdim); // initialize the matrix with zeros
time // ~13s
// pairing between curves
MatCC := Matrix(Integers(),
                [[k eq j select -4 else intersection(C, k) : k in [1..#Cs]] where C := Cs[j]
                   : j in [1..#Cs]]);
// pairing between curves and singularities
MatCP := Matrix(Integers(),
                [[pts[k] in ptC select 1 else 0 : k in [1..#pts]] where ptC := Cpts[j]
                   : j in [1..#Cs]]);
// Put the parts together
InsertBlock(~pairingmat, MatCC, 1, 1);
InsertBlock(~pairingmat, MatCP, 1, #Cs+1);
InsertBlock(~pairingmat, Transpose(MatCP), #Cs+1, 1);
// the exceptional curves are pairwise disjoint and have self-intersection -2
InsertBlock(~pairingmat, DiagonalMatrix(Integers(), [-2 : j in [1..#pts]]), #Cs+1, #Cs+1);
// Check that the matrix has rank 64. See Proposition 7.
assert Rank(pairingmat) eq 64;
printf "Have checked that the group generated by the known curves has rank 64.\n\n";

// Construct the Picard group (assuming it is generated by the known curves)
Big := RSpace(Integers(), bdim); // The free abelian group on all the curves
Pic, qPic := quo<Big | Kernel(pairingmat)>; // divisors numerically equivalent to zero are principal
// The matrix giving the projection w.r.t. the basis of Pic that Magma chooses.
MatqPic := Matrix([qPic(Big.j) : j in [1..bdim]]);

// A primitive sublattice mapping isomorphically to Pic
indlist := [ // conics a
               1,   2,   3,   4,   5,   6,   7,
               9,  10,  11,  12,  13,  14,  15,
              17,  18,  19,  20,  21,  22,  23,
              25,  26,  27,       29,
             // genus 1 curves b
              33,  34,  35,
              37,  38,
              41,
             // further genus 1 curves
              45,
              49,
              53,
              69,
             // exceptional curves
              93,  94,  95,  96,  97,  98,  99,
             101, 102, 103, 104, 105, 106, 107,
             109, 110, 111,      113,
             117, 118, 119, 120, 121,
             125, 126, 127,      129,
             133,      135 ];
assert qPic(sub<Big | [Big.j : j in indlist]>) eq Pic;

// The pairing matrix on Pic
Picbasreps := [b @@ qPic : b in Basis(Pic)]; // lift chosen basis of Pic to Big
// The matrix of the intersection pairing on the basis of Pic.
pmPic := Matrix(Integers(), [[(r1p, r2) : r2 in Picbasreps] where r1p := r1*pairingmat
                                : r1 in Picbasreps]);
// Pic as a lattice (free Z-module with a nondegenerate symmetric bilinear form)
PicL := RSpace(Integers(), 64, pmPic);
gensinPicL := [PicL!qPic(Big.j) : j in [1..bdim]];

// Find image of a curve that does not contain any of the curves in Cs
imat := Matrix(Rationals(), [[pairingmat[j,k] : k in indlist] : j in indlist])^-1;
imat *:= Matrix(Rationals(), [Eltseq(qPic(Big.j)) : j in indlist]);

function imageinPic(C)
  // Compute intersection numbers with basis of sublattice above
  iseq := [intersection(C, j) : j in indlist];
  return PicL!Eltseq(Vector(Rationals(), iseq)*imat);
end function;

// The hyperplane section
HinPic := Pic!imageinPic(Scheme(S, a1+a2+a3));
HinPicL := PicL!HinPic;

// The automorphism group (see Proposition 4)

printf "Setting up the action of Aut and Gal on Pic(S)...\n";
// First set up the permutations of the curves and points for generators of G.
substs := [[a2,a1,a3,b2,b1,b3,c], [a3,a2,a1,b3,b2,b1,c], [i*c,a2,a3,b1,i*b3,-i*b2,-i*a1],
           [-a1,a2,a3,b1,b2,b3,c], [a1,-a2,a3,b1,b2,b3,c], [a1,a2,-a3,b1,b2,b3,c],
           [a1,a2,a3,-b1,b2,b3,c], [a1,a2,a3,b1,-b2,b3,c], [a1,a2,a3,b1,b2,-b3,c]];
act := func<sch, subs | Curve(Pr6, [Evaluate(e, subs) : e in DefiningEquations(sch)])>;
function actpt(pt, subs)
  // find non-vanishing coordinate
  i0 := 1; while pt[i0] eq 0 do i0 +:= 1; end while;
  // set up a one-point scheme and act on it
  pteqns := [Pr6.j*pt[i0] - Pr6.i0*pt[j] : j in [1..7] | j ne i0];
  return Rep(Points(Scheme(Pr6, [Evaluate(e, subs) : e in pteqns])));
end function;

// For each generator, determine the permutation of the curves (+ singularities).
perms := [[Position(C1s, act(C, su)) : C in C1s]
            cat [#C1s+Position(C2s, act(C, su)) : C in C2s]
            cat [#C1s+#C2s+Position(C3s, act(C, su)) : C in C3s]
            cat [#Cs+Position(pts, actpt(pt, su)) : pt in pts]
           : su in substs];
// Descend the action to the Picard group.
actperm := func<g, perm | qPic(Big![e[perm[j]] : j in [1..#e]]) where e := Eltseq(g @@ qPic)>;

// Now the matrices of the action on Pic
action := [Matrix(Integers(), [Eltseq(actperm(Pic.j, p)) : j in [1..64]]) : p in perms];
assert forall{g : g in action | g*pmPic*Transpose(g) eq pmPic};

// Set up the automorphism group in its representation on the Picard group.
AutS := sub<GL(64, Integers()) | action>;
printf "#Aut(S) = %o\n", #AutS;

// Set up complex conjugation.
ccL := hom<L -> L | -i>; // on L
ccPL := hom<R -> R | ccL*Bang(L,R), [R.j : j in [1..7]]> where R := CoordinateRing(Pr6); // on P⁶/L
actcc := func<C | Curve(Pr6, [ccPL(e) : e in DefiningEquations(C)])>; // on curves
// Set up the induced permutations of the curves and singularities.
permcc := [Position(C1s, actcc(C)) : C in C1s]
            cat [#C1s+Position(C2s, actcc(C)) : C in C2s] 
            cat [#C1s+#C2s+Position(C3s, actcc(C)) : C in C3s]
            cat [#Cs+Position(pts, Pr6![ccL(a) : a in Eltseq(pt)]) : pt in pts];
// Descend to Pic.
ccPic := Matrix(Integers(), [Eltseq(actperm(Pic.j, permcc)) : j in [1..64]]);

// Set up the other Galois automorphism sqrt(2) -> -sqrt(2)
ctL := hom<L -> L | hom<GroundField(L) -> L | -s>, i>;
ctPL := hom<R -> R | ctL*Bang(L,R), [R.j : j in [1..7]]> where R := CoordinateRing(Pr6);
actct := func<C | Curve(Pr6, [ctPL(e) : e in DefiningEquations(C)])>;
permct := [Position(C1s, actct(C)) : C in C1s]
            cat [#C1s+Position(C2s, actct(C)) : C in C2s]
            cat [#C1s+#C2s+Position(C3s, actct(C)) : C in C3s]
            cat [#Cs+Position(pts, Pr6![ctL(a) : a in Eltseq(pt)]) : pt in pts];
ctPic := Matrix(Integers(), [Eltseq(actperm(Pic.j, permct)) : j in [1..64]]);

// Automorphisms + Galois on Pic/2*Pic
AutSGal := sub<GL(64, GF(2)) | [Eltseq(g) : g in Generators(AutS)] cat [Eltseq(ccPic), Eltseq(ctPic)]>;
Syl2Aut := SylowSubgroup(AutSGal, 2); // a Sylow 2-subgroup
PicM := GModule(Syl2Aut); // Pic as a representation of the Sylow 2-subgroup
// Take invariants intersected with subspace of elements having even intersection with everything
// and check that this has dimension 1. See Theorem 8.
assert Dimension(Fix(PicM) meet sub<PicM | Basis(Kernel(ChangeRing(pmPic, GF(2))))>) eq 1;
printf "\nHave verified that Pic(S) is generated by known curves\n";
printf "IF the hyperplane section is not divisible by 2 (which is true by Lemma 5).\n\n";

// Set up the Galois group and compute the algebraic part of the Brauer Group
Gal := sub<GL(64,Integers()) | [ccPic, ctPic]>;
PicMod := GModule(Gal);
CM := CohomologyModule(Gal, PicMod);
H1 := CohomologyGroup(CM, 1);
assert #H1 eq 1; // It is trivial! See Theorem 10.
printf "Have verified that the algebraic Brauer group of S over Q equals Br_0.\n\n";

// The orthogonal complement of the hyperplane section w.r.t. the intersection pairing
Hperp := Kernel(Transpose(Matrix([HinPic])*pmPic));

// The (positive definite) negative of the intersection pairing on Hperp
pospmHperp := -BasisMatrix(Hperp)*pmPic*Transpose(BasisMatrix(Hperp));
LHp := LatticeWithGram(pospmHperp); // ... as a lattice
HperpMod := RSpace(Integers(), 63); // ... as an abstract Z-module
HperptoPic := hom<HperpMod -> Pic | Basis(Hperp)>; // and its inclusion in Pic

// The following computations take a while. Set quick to false to perform them.
if not quick then

printf "Now looking at low degree curves on S.\n";
printf "A conic C on S has C^2 = -4 and degree 2.\n";
printf "We enumerate all such classes in Pic(S)...\n";

base2 := LHp!Eltseq((qPic(8*Big.1) - HinPic) @@ HperptoPic); // base point
// Use C |--> 8*C - H in Hperp,  then (8*C-H)^2 = 64 C^2 - 16 = -16*17
// Note that  8*C - H = (8*C_0 - H) + 8*(C - C_0) = base2 - 8*(something in Hperp),
// so we look for vectors x in 8*Hperp such that the norm of (x - base2) is 16*17.
time clv := CloseVectors(8*LHp, base2, 16*17); // ~30s
// The resulting classes must have nonnegative intersection with the known curves
// if they come from unknown conics.
printf "...there are %o; now we check which ones have nonnegative intersection\n", #clv;
printf "  with the curves we know...\n";
cands2 := [v : cv in clv | forall{j : j in [1..bdim] | (v, gensinPicL[j]) ge 0}
                where v := PicL!(qPic(Big.1) - HperptoPic(Eltseq(LHp!(1/8*cv[1]))))];
assert IsEmpty(cands2);
// See Theorem 15 (1).
printf "We don't find any, so there are no unknown conics.\n\n";

printf "Now we consider (integral) curves of degree 4 on S.\n";
printf "Such a curve C must have p_a(C) <= 1, so C^2 = -4 or C^2 = -6.\n";
printf "We look at the case p_a(C) = 1, so C^2 = -4.\n";
printf "We enumerate all the relevant classes in Pic(S)...\n";
// Use C |--> 4*C - H, then (4*C-H)^2 = 16 C^2 - 16 = -16*5
// We proceed as above.
time clv := CloseVectors(4*LHp, base2, 16*5, 16*5); // ~4 min
printf "...there are %o, and check which ones have nonnegative intersection\n", #clv;
printf "  with the curves we know...\n";
time // ~8s
cands4p1 := [v : cv in clv | forall{j : j in [1..bdim] | (v, gensinPicL[j]) ge 0}
                   where v := PicL!(qPic(2*Big.1) - HperptoPic(Eltseq(LHp!(1/4*cv[1]))))];
assert IsEmpty(cands4p1);
// See Theorem 15 (3).
printf "We don't find any, so there are no unknown such curves.\n\n";

end if; // not quick


printf "============================================================================\n";

// Now repeat this for the K3 quotient obtained by forgetting c. See Section 6.
// The set-up follows what we did for S-bar earlier.
printf "\nNow setting up K3 quotient...\n";
Pr5<A1,A2,A3,B1,B2,B3> := ProjectiveSpace(L, 5);

// The defining equations of the surface K_c-bar
eqnsK := [A1^2 + A2^2 - B3^2, A2^2 + A3^2 - B1^2, A1^2 + A3^2 - B2^2];

// Define the surface
K := Scheme(Pr5, eqnsK);

// The singular points
ptsK := Points(SingularSubscheme(K));
assert #ptsK eq 12;

printf "Constructing known curves on K...\n";
            // one orbit of conics
C1sK :=     [Curve(K, [A1, A2+e1*B3, A3+e2*B2]) : e1,e2 in [1,-1]]
        cat [Curve(K, [A2, A3+e1*B1, A1+e2*B3]) : e1,e2 in [1,-1]]
        cat [Curve(K, [A3, A1+e1*B2, A2+e2*B1]) : e1,e2 in [1,-1]]
            // these are the branch conics (another orbit)
        cat [Curve(K, [i*A1+e1*B1, i*A2+e2*B2, i*A3+e3*B3]) : e3,e2,e1 in [1,-1]];

            // one orbit of genus 1 curves
C2sK :=     [Curve(K, [B1, i*A2+e1*A3]) : e1 in [1,-1]]
        cat [Curve(K, [B2, i*A3+e1*A1]) : e1 in [1,-1]]
        cat [Curve(K, [B3, i*A1+e1*A2]) : e1 in [1,-1]];

            // another orbit of conics
C3sK :=     [Curve(K, [A1+e1*A2, s*A1+e2*B3, B1+e3*B2]) : e1,e2,e3 in [1,-1]]
        cat [Curve(K, [A2+e1*A3, s*A2+e2*B1, B2+e3*B3]) : e1,e2,e3 in [1,-1]]
        cat [Curve(K, [A3+e1*A1, s*A3+e2*B2, B3+e3*B1]) : e1,e2,e3 in [1,-1]]
            // and an orbit of genus 1 curves
        cat [Curve(K, [i*B2+e2*B3, i*s*A1+e3*B1]) : e3,e2 in [1,-1]]
        cat [Curve(K, [i*B3+e2*B1, i*s*A2+e3*B2]) : e3,e2 in [1,-1]]
        cat [Curve(K, [i*B1+e2*B2, i*s*A3+e3*B3]) : e3,e2 in [1,-1]];

// All the curves...
CsK := C1sK cat C2sK cat C3sK;
GsK := [ArithmeticGenus(C) : C in CsK];
// ...and the singular points on them
CptsK := [{pt : pt in ptsK | pt in C} : C in CsK];

// Set up the intersection pairing
function intersectionK(C, j)
  // j is index in "CsK cat ptsK"
  if j le #CsK then
    m := 0;
    CC := C meet CsK[j];
    if Dimension(CC) eq 1 then
      while IsSubscheme(CsK[j], C) do
        m +:= 1;
        C := Difference(C, CsK[j]);
      end while;
      CC := C meet CsK[j];
      assert Dimension(CC) lt 1;
      return m*2*(GsK[j] - 1) + Degree(CC)
              - &+[Integers()|Multiplicity(C, pt) : pt in CptsK[j] | pt in C];
    else
      return Degree(CC) - &+[Integers()|Multiplicity(C, pt) : pt in CptsK[j] | pt in C];
    end if;
  else
    pt := ptsK[j-#CsK];
    return pt in C select Multiplicity(C, pt) else 0;
  end if;
end function;

// The pairing matrix;
// we take the curves first, then the exceptional divisors (represented
//  by the singularities)
printf "Setting up intersection matrix for K...\n";
bdimK := #CsK + #ptsK;
pairingmatK := ZeroMatrix(Integers(), bdimK, bdimK);
MatCCK := SymmetricMatrix(Integers(),
                [k eq j select 2*(GsK[j] - 1) else intersectionK(CsK[j], k)
                    : k in [1..j], j in [1..#CsK]]);
MatCPK := Matrix(Integers(),
                [[ptsK[k] in ptC select 1 else 0 : k in [1..#ptsK]] where ptC := CptsK[j]
                   : j in [1..#CsK]]);
InsertBlock(~pairingmatK, MatCCK, 1, 1);
InsertBlock(~pairingmatK, MatCPK, 1, #CsK+1);
InsertBlock(~pairingmatK, Transpose(MatCPK), #CsK+1, 1);
InsertBlock(~pairingmatK, DiagonalMatrix(Integers(), [-2 : j in [1..#ptsK]]),
                          #CsK+1, #CsK+1);
assert Rank(pairingmatK) eq 20;

// Construct the Picard group
printf "Set up the Picard group of K...\n";
BigK := RSpace(Integers(), bdimK);
PicK, qPicK := quo<BigK | Kernel(pairingmatK)>;
MatqPicK := Matrix([qPicK(BigK.j) : j in [1..bdimK]]);

indlistK := [ 2, 4, 5, 7, 9, 10, 20, 21, 26, 35, 39, 42, 44, 47, 49, 52, 54, 64, 67, 72 ];
assert sub<PicK | [qPicK(BigK.j) : j in indlistK]> eq PicK;

// The pairing matrix on PicK
PicbasrepsK := [b @@ qPicK : b in Basis(PicK)];
pmPicK := Matrix(Integers(), [[(r1p, r2) : r2 in PicbasrepsK] where r1p := r1*pairingmatK
                                : r1 in PicbasrepsK]);

// The hyperplane section
hyp0K := &+pairingmatK[1..4];
HinPicK := qPicK(BigK!([1,1,1,1] cat [0 : j in [5..#CsK]] cat [hyp0K[j] div 2 : j in [#CsK+1..bdimK]]));

// Pic(K) as quadratic space
PicKL := RSpace(Integers(), 20, pmPicK);
gensinPicKL := [PicKL!qPicK(BigK.j) : j in [1..bdimK]];
HinPicKL := PicKL!HinPicK;

// Find image of a curve that does not contain any of the curves in CsK
imatK := Matrix(Rationals(), [[pairingmatK[j,k] : k in indlistK] : j in indlistK])^-1;
imatK *:= Matrix(Rationals(), [Eltseq(qPicK(BigK.j)) : j in indlistK]);

function imageinPicK(C)
  // Compute intersection numbers with basis of sublattice above
  iseq := [intersectionK(C, j) : j in indlistK];
  return PicKL!Eltseq(Vector(Rationals(), iseq)*imatK);
end function;


printf "\nConstructing canonical maps Pic(S) --> Pic(K) and Pic(K) --> Pic(S)...\n";

proj := map<Pr6 -> Pr5 | [a1,a2,a3,b1,b2,b3]>;

images := [<Position(CsK, C), ExactQuotient(Degree(Cs[j]), Degree(C))> where C := proj(Cs[j])
            : j in [1..#Cs]]
           cat [proj(pt) in ptsK select <Position(ptsK, proj(pt))+#CsK, 1> else <0, 0> : pt in pts];
imgsinPicK := [qPicK(BigK![j eq a[1] select a[2] else 0 : j in [1..bdimK]]) : a in images];

MatBigtoBigK := ZeroMatrix(Integers(), bdim, bdimK);
for j := 1 to #images do
  if images[j,1] ne 0 then MatBigtoBigK[j, images[j,1]] := images[j,2]; end if;
end for;

PicStoPicK := hom<Pic -> PicK | [&+[s[j]*imgsinPicK[j] : j in [1..#s]] where s := Eltseq(b)
                                  : b in Picbasreps]>;

// now the pull-back
// be careful with exceptional curves on S that are contracted
flattened := [proj(pt) : pt in pts[25..#pts]];
preimages := [&+[Integers()| a[2] : a in s] eq 2 select [<a[1], 1> : a in s] else [<s[1,1], 2>]
                where s := [<k, images[k,2]> : k in [1..#images] | images[k,1] eq j]
               : j in [1..bdimK]];
for j := 1 to #CsK do
  preimages[j] cat:= [<#Cs+24+k, Multiplicity(CsK[j], flattened[k])>
                       : k in [1..#flattened] | flattened[k] in CsK[j]];
end for;
MatBigKtoBig:= ZeroMatrix(Integers(), bdimK, bdim);
for j := 1 to bdimK do
  for a in preimages[j] do
    MatBigKtoBig[j, a[1]] := a[2];
  end for;
end for;

preimsinPic := [qPic(Big![pos gt 0 select pr[pos,2] else 0 where pos := Position([a[1] : a in pr], j)
                            : j in [1..bdim]])
                 : pr in preimages];
PicKtoPicS := hom<PicK -> Pic | [&+[s[j]*preimsinPic[j] : j in [1..#s]] where s := Eltseq(b)
                                  : b in PicbasrepsK]>;

// represent maps as matrices
MatStoK := Matrix(Integers(), [Eltseq(PicStoPicK(b)) : b in Basis(Pic)]);
MatKtoS := Matrix(Integers(), [Eltseq(PicKtoPicS(b)) : b in Basis(PicK)]);
// Sanity checks:
assert MatKtoS*MatStoK eq 2*IdentityMatrix(Integers(), 20);
assert MatKtoS*pmPic*Transpose(MatKtoS) eq 2*pmPicK;
assert Matrix(PicbasrepsK)*MatBigKtoBig*MatqPic eq MatKtoS;

// action of sign change of c
signc := &*action[4..9]; // = sign change of all other coordinates
// The "trace" -- note that trcE = pi^* pi_*; see Lemma 11.
trcE := hom<Pic -> Pic | [g + Pic!(Vector(Eltseq(g))*signc)
                            + &+[(PicL!g, gensinPicL[k])*qPic(Big.k) : k in [#Cs+25..bdim]]
                            where g := Pic.j : j in [1..64]]>;
ImtrcE := Image(trcE);
mattrcE := Matrix([Eltseq(trcE(Pic.j)) : j in [1..64]]);

// can check that  ImK/(ImK meet Imtrc) = (Z/2)^9  where ImK = image of Pic(K) in Pic(S).
// can check that  ImK/(ImK meet ImtrcE) = (Z/2)^2  where ImK = image of Pic(K) in Pic(S).
// can check that  PicKK/Image(PicStoPicKK) = (Z/2)^17

// find preimage of ImtrcE in PicK = image of PicStoPicK
// ImtrcEK := ImtrcE meet Image(PicKtoPicS);
// matImtrcEK := Matrix([Eltseq(b) : b in Basis(ImtrcEK)]);
// matPicK1, ker := Solution(MatKtoS, matImtrcEK);
// assert Dimension(ker) eq 0;
PicK1 := Image(PicStoPicK); // PicK1 := sub<PicK | [PicK| matPicK1[j] : j in [1..20]]>;
// PicK2 := Image(PicKKtoPicK);

printf "\nSetting up the action of Aut and Gal on Pic(K)...\n";
// First set up the permutations of the curves and points
substsK := [[A2,A1,A3,B2,B1,B3], [A3,A2,A1,B3,B2,B1],
           [-A1,A2,A3,B1,B2,B3], [A1,-A2,A3,B1,B2,B3], [A1,A2,-A3,B1,B2,B3],
           [A1,A2,A3,-B1,B2,B3], [A1,A2,A3,B1,-B2,B3]];
actK := func<sch, subs | Curve(Pr5, [Evaluate(e, subs) : e in DefiningEquations(sch)])>;
function actptK(pt, subs)
  i0 := 1; while pt[i0] eq 0 do i0 +:= 1; end while;
  pteqns := [Pr5.j*pt[i0] - Pr5.i0*pt[j] : j in [1..6] | j ne i0];
  return Rep(Points(Scheme(Pr5, [Evaluate(e, subs) : e in pteqns])));
end function;

permsK := [[Position(C1sK, actK(C, su)) : C in C1sK]
            cat [#C1sK+Position(C2sK, actK(C, su)) : C in C2sK]
            cat [#C1sK+#C2sK+Position(C3sK, actK(C, su)) : C in C3sK]
            cat [#CsK+Position(ptsK, actptK(pt, su)) : pt in ptsK]
           : su in substsK];
actpermK := func<g, perm | qPicK(BigK![e[perm[j]] : j in [1..#e]])
                           where e := Eltseq(g @@ qPicK)>;

// Now the matrices of the action on Pic
actionK := [Matrix(Integers(), [Eltseq(actpermK(PicK.j, p)) : j in [1..20]]) : p in permsK];
assert forall{g : g in actionK | g*pmPicK*Transpose(g) eq pmPicK};

AutK := sub<GL(20, Integers()) | actionK>;
printf "#Aut(K) = %o\n", #AutK;

assert Rank(ChangeRing(MatKtoS, GF(2))) eq 20;
// We get an injective map into Pic(S)/2*Pic(S), so our subgroup of Pic(K) is 2-saturated.
// See Lemma 12.
printf "\nHave verified that Pic(K) is generated by known curves.\n";
printf "In particular, there are no curves of odd degree on K.\n\n";

printf "=========================================================================\n\n";

// set up lattice H^perp

HperpK := Kernel(Transpose(Matrix([HinPicK])*pmPicK));
HperpK1 := HperpK meet PicK1;

pospmHperpK := -BasisMatrix(HperpK)*pmPicK*Transpose(BasisMatrix(HperpK));
LHpK := LatticeWithGram(pospmHperpK);
HperpKMod := RSpace(Integers(), 19);
HperpKtoPicK := hom<HperpKMod -> PicK | Basis(HperpK)>;

pospmHperpK1 := -BasisMatrix(HperpK1)*pmPicK*Transpose(BasisMatrix(HperpK1));
LHpK1 := LatticeWithGram(pospmHperpK1);
HperpK1toPicK1 := hom<HperpKMod -> PicK1 | Basis(HperpK1)>;

// find the orbits of a finite group acting on a finite set
function orbits(group, set)
  os := [];
  while not IsEmpty(set) do
    r := Rep(set);
    o := r^group;
    set diff:= o;
    Append(~os, o);
  end while;
  return os;
end function;

if not quick then

// conics on K: Lemma 13 (1)
printf "A conic C on K has C^2 = -2 and degree 2.\n";
printf "We find all classes in Pic(K) with these properties...\n";
base2 := LHpK!Eltseq((qPicK(4*BigK.1) - HinPicK) @@ HperpKtoPicK); // base point
// use C |--> 4*C - H; (4*C-H)^2 = 16 C^2 - 8 = -40
clv := CloseVectors(4*LHpK, base2, 40); // fast
printf "...there are %o, and check which ones have nonnegative intersection\n", #clv;
printf "  with the curves we know...\n";
cands2 := [v : cv in clv | forall{j : j in [1..bdimK] | (v, gensinPicKL[j]) ge 0}
                 where v := PicKL!(qPicK(BigK.1) - HperpKtoPicK(Eltseq(LHpK!(1/4*cv[1]))))];
assert IsEmpty(cands2);
printf "We don't find any, so there are no unknown conics.\n\n";

// Lemma 13 (2), (3)
printf "Now we consider (integral) curves of degree 4 on K.\n";
printf "Such a curve C must span a P^3 or a P^4, so C^2 = -2 or C^2 = 0.\n";
printf "We enumerate all the relevant classes in Pic(K)...\n";
// use C |--> 2*C - H; (2*C-H)^2 = 4 C^2 - 8 = -8 or -16
time clv := CloseVectors(2*LHpK, base2, 8, 16);
printf "...there are %o, and check which ones have nonnegative intersection\n", #clv;
printf "  with the curves we know...\n";
time cands4p1 := [v : cv in clv | cv[2] eq 8
                                   and forall{j : j in [1..bdimK] | (v, gensinPicKL[j]) ge 0}
                   where v := PicKL!(qPicK(2*BigK.1) - HperpKtoPicK(Eltseq(LHpK!(1/2*cv[1]))))];
time cands4p0 := [v : cv in clv | cv[2] eq 16
                                   and forall{j : j in [1..bdimK] | (v, gensinPicKL[j]) ge 0}
                   where v := PicKL!(qPicK(2*BigK.1) - HperpKtoPicK(Eltseq(LHpK!(1/2*cv[1]))))];
orb4p1 := orbits(AutK, Set(cands4p1));
orb4p0 := orbits(AutK, Set(cands4p0));
printf "There are %o with C^2 = 0, falling into %o orbits under Aut(K),\n", #cands4p1, #orb4p1;
printf "  and %o with C^2 = -2, falling into %o orbits under Aut(K).\n", #cands4p0, #orb4p0;
assert #cands4p1 eq 15;
printf "Those with C^2 = 0 are taken care of by the 15 elliptic fibrations.\n";
printf "Those with C^2 = -2 must be smooth rational normal curves of degree 4.\n";
cands4p0 := [v : v in cands4p0 | forall{j : j in [#CsK+1..bdimK] | (v, gensinPicKL[j]) le 1}];
orb4p0 := orbits(AutK, Set(cands4p0));
printf "Ruling out classes meeting some singular point with multiplicity > 1,\n";
printf "  we are left with %o classes, falling into %o orbits under Aut(K).\n", #cands4p0, #orb4p0;
assert {* #o : o in orb4p0 *} eq {* 8, 48 *};
// Define a representative of the orbit of size 48
C4K := Curve(IrreducibleComponents(Scheme(K, A1+s*i*A2+A3+B2))[1]);
C4Kp := imageinPicK(C4K);
assert PicKL!C4Kp in cands4p0; // its class is among the candidates
// Determine its orbit under the group induced by Aut(S)
C4sK := [C4K];
orb := {C4Kp};
orbseq := [C4Kp];
repeat
  for k := 1 to #substsK do
    su := substsK[k];
    g := AutK!actionK[k];
    for j := 1 to #orbseq do
      new := orbseq[j]^g;
      if new notin orb then
        Include(~orb, new);
        Append(~orbseq, new);
        Append(~C4sK, actK(C4sK[j], su));
      end if;
    end for;
  end for;
until #C4sK eq 48;
// Same for the orbit of size 8
C5K := Curve(IrreducibleComponents(Scheme(K, B1+B2+B3))[1]);
C5Kp := imageinPicK(C5K);
assert PicKL!C5Kp in cands4p0;
C5sK := [C5K];
orb := {C5Kp};
orbseq := [C5Kp];
repeat
  for k := 1 to #substsK do
    su := substsK[k];
    g := AutK!actionK[k];
    for j := 1 to #orbseq do
      new := orbseq[j]^g;
      if new notin orb then
        Include(~orb, new);
        Append(~orbseq, new);
        Append(~C5sK, actK(C5sK[j], su));
      end if;
    end for;
  end for;
until #C5sK eq 8;
printf "They are accounted for by explicit curves we find on K.\n\n";

end if; // not quick

// Set up code for the following:
// We want to check if a class D in Pic(K) could possibly
//  be the image of an integral curve C on S with deg(C) = deg(D).
// A necessary condition is that D' = PicKtoPicS(D) is in ImtrcE, since D' = trcE(C).
// The possible classes C are the preimages C' of D' under trcE
//  such that p_a(C') >= 0, i.e., C'^2 >= -2 - deg(D),
//  and C'.F >= 0 for all known curves F on S.

kertrmat := BasisMatrix(Kernel(trcE));
kertrmatQ := ChangeRing(kertrmat, Rationals());
kertrgram := -kertrmat*pmPic*Transpose(kertrmat);
assert IsPositiveDefinite(kertrgram);
LkertrcE := LatticeWithGram(kertrgram);
kertrgramQ := ChangeRing(kertrgram, Rationals());
assert NumberOfRows(kertrmat) eq 44;
kertrbasinPicL := [PicL!kertrmat[j] : j in [1..44]];
pmPicQ := ChangeRing(pmPic, Rationals());

function liftcands(v) // v in PicK, corresponds to D above
  deg := (PicKL!v, HinPicKL);
  vS := PicKtoPicS(v); // pull-back to S
  if not vS in Image(trcE) then return []; end if;
  printf "liftcands: computing close vectors...\n";
  pre := vS @@ trcE; // find one preimage
  // project to kernel
  pr0 := Solution(kertrgramQ,
                  -Vector(Rationals(), [(PicL!pre, kertrbasinPicL[j]) : j in [1..44]]));
  bound := 2 + deg + (pp*pmPicQ, pp) where pp := ChangeRing(pre, Rationals()) - pr0*kertrmatQ;
  // (pre - v)^2 = (pre - pre0)^2 + (pre0 - v)^2 for v in the kernel;
  // note sign change of the quadratic form on the lattice
  time clv := CloseVectors(LkertrcE, pr0, bound);
  printf "           there are %o candidates.\n", #clv;
  cands := [PicL!(pre - Vector(cv[1])*kertrmat) : cv in clv];
  // now check for numerical effectivity
  printf "liftcands: checking for numerical effectivity...\n";
  time cands := [v : v in cands | forall{g : g in gensinPicL | (v, g) ge 0}];
  printf "           %o candidates remaining.\n", #cands;
  return cands;
end function;

assert IsEven(Dimension(LkertrcE));
LkertrcE_vol := Pi(RealField())^d/Factorial(d)/Sqrt(Determinant(LkertrcE))
  where d := ExactQuotient(Dimension(LkertrcE), 2);

// A variant using CloseVectorsProcess
function liftcands_pr(v) // v in PicK, corresponds to D above
  deg := (PicKL!v, HinPicKL);
  vS := PicKtoPicS(v); // pull-back to S
  if not vS in Image(trcE) then return []; end if;
  printf "liftcands: computing close vectors...\n";
  pre := vS @@ trcE; // find one preimage
  // project to kernel
  pr0 := Solution(kertrgramQ,
                  -Vector(Rationals(), [(PicL!pre, kertrbasinPicL[j]) : j in [1..44]]));
  bound := 2 + deg + (pp*pmPicQ, pp) where pp := ChangeRing(pre, Rationals()) - pr0*kertrmatQ;
  // (pre - v)^2 = (pre - pre0)^2 + (pre0 - v)^2 for v in the kernel;
  // note sign change of the quadratic form on the lattice
  printf "  bound = %o,  expected number of close vectors: %o\n",
         bound, ChangePrecision(LkertrcE_vol * bound^ExactQuotient(Dimension(LkertrcE), 2), 10);
  cands := [];
  count := 0;
  Pr := CloseVectorsProcess(LkertrcE, pr0, bound);
  time
  while not IsEmpty(Pr) do
    cv := NextVector(Pr);
    count +:= 1;
    v := PicL!(pre - Vector(cv)*kertrmat);
    if forall{g : g in gensinPicL | (v, g) ge 0} then
      Append(~cands, v);
    end if;
    if IsDivisibleBy(count, 10^6) then printf " ... %o vectors checked\n", count; end if;
  end while;
  printf "  there were originally %o candidates.\n", count;
  printf "  %o candidates remaining after checking for numerical effectivity.\n", #cands;
  return cands;
end function;

if not quick then

printf "A curve of degree 6 on S must map to a sextic on K.\n";
printf "We can show that irreducible sextics in hyperplane sections of K\n";
printf "  lift to irreducible curves of degree 12 on S.\n";
printf "So an irreducible sextic C on S must span a P^5 or the P^6 and has p_a(C) <= 1.\n";
printf "Its image C' on K spans P^5, so still has p_a(C') <= 1.\n";
printf "This means that C'^2 = -2 or 0.\n";
printf "We find all such C' in the image of Pic(S) --> Pic(K).\n";
base0 := 3*qPicK(BigK.1);
base := LHpK1!Eltseq((qPicK(12*BigK.1) - 3*HinPicK) @@ HperpK1toPicK1); // base point coming from 3*conic
time clv := CloseVectors(4*LHpK1, base, 104);
clv1 := [a[1] : a in clv | a[2] eq 72];
clv0 := [a[1] : a in clv | a[2] eq 104];
printf "There are %o classes with C^2 = 0 and %o classes with C^2 = -2.\n", #clv1, #clv0;
printf "Now we check which corresponding C's have nonnegative intersection\n";
printf "  with the curves we know...\n";
time cands1 := [v : cv in clv1 | forall{j : j in [1..bdimK] | (v, gensinPicKL[j]) ge 0}
             where v := PicKL!(base0 - HperpK1toPicK1(Eltseq(LHpK1!(1/4*cv))))];
time cands0 := [v : cv in clv0 | forall{j : j in [1..bdimK] | (v, gensinPicKL[j]) ge 0}
             where v := PicKL!(base0 - HperpK1toPicK1(Eltseq(LHpK1!(1/4*cv))))]; // ~13 seconds
printf "There are %o such classes with C^2 = 0 and %o with C^2 = -2,\n", #cands1, #cands0;
orbrep1 := [Rep(o) : o in orbits(AutK, Set(cands1))];
orbrep0 := [Rep(o) : o in orbits(AutK, Set(cands0))];
printf "  falling into %o (p_a = 1) and %o (p_a = 0) orbits\n", #orbrep1, #orbrep0;
printf "  under the linear automorphisms of K.\n";
printf "Now we check which of these might be the image of a curve on S...\n";
for v in orbrep1 do time assert IsEmpty(liftcands_pr(v)); end for;
for v in orbrep0 do time assert IsEmpty(liftcands_pr(v)); end for;
printf "... None of them is.\n";
printf "This now implies that there are no curves of degree 6 on S.\n\n";

end if; // not quick

printf "=========================================================================\n\n";

printf "Proof of Lemma 14\n\n";

// The indices in CsK of the 44 conics on K
con_inds := [i : i in [1..#CsK] | Degree(CsK[i]) eq 2];
// The conics themselves
conicsK := CsK[con_inds];
assert #con_inds eq 44;

// The intersection matrix restricted to the conics
pairingmatK_con := Submatrix(pairingmatK, con_inds, con_inds);

// The eight branch concis
branch_con := [X : X in conicsK | X subset Scheme(K, A1^2+A2^2+A3^2)];
brcon_inds := [i : i in [1..44] | conicsK[i] in branch_con];
assert #brcon_inds eq 8;

nonbr_inds := [i : i in [1..44] | i notin brcon_inds]; // indices of non-branch conics

// Check that each non-branch conic intersects exactly four branch conics
// and with intersection multiplicity 1.
assert forall{i : i in nonbr_inds
                | {* a : a in Eltseq(pairingmatK_con[i])[brcon_inds] *} eq {* 0^^4, 1^^4 *}};

// Verify that the four branch conics met by a non-branch conic split into two pairs
// such that the conics in one pair intersect transversally in two distinct points
// and the conics in distinct pairs do not meet.
br_inters := [[j : j in brcon_inds | pairingmatK_con[i, j] eq 1] : i in nonbr_inds];
good_mats :=
  [ Matrix([[-2,2,0,0], [2,-2,0,0], [0,0,-2,2], [0,0,2,-2]]),
    Matrix([[-2,0,2,0], [0,-2,0,2], [2,0,-2,0], [0,2,0,-2]]),
    Matrix([[-2,0,0,2], [0,-2,2,0], [0,2,-2,0], [2,0,0,-2]]) ];
assert forall{s : s in br_inters | Submatrix(pairingmatK_con, s, s) in good_mats};
assert forall{0 : a, b in s, s in br_inters
                | Dimension(int) ne 0 or IsReduced(int) where int := conicsK[a] meet conicsK[b]};

// There are two orbits of non-branch concis of sizes 12 and 24,
// represented by conicsK[1] and conicsK[21] = conicsK[nonbr_inds[13]].
// It suffices to check the claims for one representative of each orbit.

// First orbit
assert br_inters[1] eq [15, 16, 17, 18];
assert Submatrix(pairingmatK_con, br_inters[1], br_inters[1]) eq good_mats[1]; // 1 2, 3 4
// In this case, the non-branch conic meets two and two branch conics in the same point.
assert conicsK[1] meet conicsK[15] eq conicsK[1] meet conicsK[16];
assert conicsK[1] meet conicsK[17] eq conicsK[1] meet conicsK[18];
// The linear forms defining the plane containing the non-branch conic
linforms := DefiningEquations(conicsK[1])[1..3];
pt1 := Rep(Points(conicsK[1] meet conicsK[15]));
pt2 := Rep(Points(conicsK[1] meet conicsK[17]));
pt1a := Rep(Points(conicsK[15] meet conicsK[16]) diff {@ pt1 @});
pt2a := Rep(Points(conicsK[17] meet conicsK[18]) diff {@ pt2 @});
// pts := Points(conicsK[15] meet conicsK[16]) join Points(conicsK[17] meet conicsK[18]);
// Find extra linear condition for containing the tangent line etc.
// The tangent hyperplane to the cone A1^2 + A2^2 + A3^2 = 0 at the point (x:y:z)
// is given by x*A1 + y*A2 + z*A3 = 0. We intersect with the plane containing the
// branch conic to get the tangent line.
lpt1 := Scheme(Ambient(K),
               DefiningEquations(conicsK[15])[1..3] cat [&+[pt1[j]*[A1,A2,A3][j] : j in [1..3]]]);
// We find a point on it (different from pt1); the hyperplane has to contain it.
// (Adding the condition that it contains the tangent line to the other conic is redundant.)
pt1b := Rep(Points(Scheme(lpt1, A1 - A3)));
// Same for the other pair of branch conics.
lpt2 := Scheme(Ambient(K),
                DefiningEquations(conicsK[17])[1..3] cat [&+[pt2[j]*[A1,A2,A3][j] : j in [1..3]]]);
pt2b := Rep(Points(Scheme(lpt2, A1 - A3)));
pts := [pt1a, pt1b, pt2a, pt2b];
// Evaluate the linear forms on the relevant points.
mat := Matrix([[Evaluate(l, Eltseq(pt)) : l in linforms] : pt in pts]);
submats := [Submatrix(mat, [i,j], [1..3]) : i in [1,2], j in [3,4]];
// Deal with the choices that lead to a unique hyperplane.
hyperplanes := [];
for m in submats do
  if Rank(m) eq 2 then
    Append(~hyperplanes,
           &+[s[j]*linforms[j] : j in [1..3]] where s := Eltseq(KernelMatrix(Transpose(m))));
  end if;
end for;
assert #hyperplanes eq 3;
// Look at the degree 6 components of the intersection of K with each hyperplane.
deg6 := [c : c in &cat[IrreducibleComponents(Scheme(K, h)) : h in hyperplanes] | Degree(c) eq 6];
assert IsEmpty(deg6); // no such components exist.
// Now consider the remaining pencil of hyperplanes.
m := Rep({m : m in submats | Rank(m) eq 1});
// Take the P³ that is the intersection of all hyperplanes in the pencil.
plane := [&+[k[i,j]*linforms[j] : j in [1..3]] : i in [1..Nrows(k)]]
           where k := KernelMatrix(Transpose(m));
// Intersect with K and split into components.
irrKp := IrreducibleComponents(Scheme(K, plane));
// Verify that the intersection contains a conic with multiplicity 2.
assert #irrKp eq 1 and Dimension(irrKp[1]) eq 1 and Degree(irrKp[1]) eq 4
         and Degree(ReducedSubscheme(irrKp[1])) eq 2;
printf "Verified the statement for the 'other orbit' of non-branch conics.\n\n";

// Second orbit
assert br_inters[13] eq [13, 16, 17, 20];
assert Submatrix(pairingmatK_con, br_inters[13], br_inters[13]) eq good_mats[2]; // 1 3, 2 4
// The linear forms defining the plane containing the non-branch conic
linforms := DefiningEquations(conicsK[21])[1..3];
pts := Points(conicsK[13] meet conicsK[17]) join Points(conicsK[16] meet conicsK[20]);
mat := Matrix([[Evaluate(l, Eltseq(pt)) : l in linforms] : pt in pts]);
submats := [Submatrix(mat, [i,j], [1..3]) : i in [1,2], j in [3,4]];
assert forall{m : m in submats | Rank(m) eq 2};
// So picking one intersectiion point for each pair, there is a unique hyperplane
// through the non-branch conic and these two points. Determine them.
hyperplanes := [&+[s[j]*linforms[j] : j in [1..3]] where s := Eltseq(KernelMatrix(Transpose(m)))
                 : m in submats];
// Look at the degree 6 components of the intersection of K with each hyperplane.
deg6 := [c : c in &cat[IrreducibleComponents(Scheme(K, h)) : h in hyperplanes] | Degree(c) eq 6];
assert #deg6 eq 2;
// Verify that the intersection with the branch locus contains points of multiplicity one.
assert forall{s : s in deg6
                | exists{c : c in IrreducibleComponents(Scheme(s, A1^2+A2^2+A3^2)) | IsReduced(c)}};
printf "Verified the statement for the first orbit of non-branch conics.\n\n";

// The residual conic is a branch conic. W.l.o.g., it is the first one.
// Find the four other branch conics that do not meet it.
dj_inds := [i : i in [1..#branch_con] | IsEmpty(branch_con[1] meet branch_con[i])];
assert #dj_inds eq 4;
// Each hyperplane equation is a linear combination of the linear forms
// among the defining equation of the conic.
linforms := DefiningEquations(branch_con[1])[1..3];
// To find the condition for the hyperplane to be tangent to one of the
// four other conics, we parameterize each of them in terms of (p : q) and
// plug this into the generic hyperplane equation to obtain a quadratic equation
// in p and q; then the condition is that the discriminant of this quadratic form vanishes.
P3L<[r]> := PolynomialRing(L, 3); // r[1]*linforms[1] + ... + r[3]*linforms[3] is the hyperplane
P2P3L<p,q> := PolynomialRing(P3L, 2);
params := [[2*p*q, p^2-q^2, i*(p^2+q^2), e1*i*2*p*q, e2*i*(p^2-q^2), -e3*(p^2+q^2)]
            where e1,e2,e3 := Explode(e) : e in [[1,1,-1],[1,-1,1],[-1,1,1],[1,1,1]]];
assert forall{i : e in DefiningEquations(branch_con[dj_inds[i]]), i in [1..4]
                | Evaluate(e, params[i]) eq 0};
// Plug in.
pols := [&+[r[j]*Evaluate(linforms[j], par) : j in [1..3]] : par in params];
assert IsHomogeneous(pols) and forall{pol : pol in pols | Degree(pol) eq 2};
// Compute discriminants.
discs := [MC(pol, p*q)^2/4 - MC(pol, p^2)*MC(pol, q^2) : pol in pols] where MC := MonomialCoefficient;
// Verify that they cannot all vanish.
assert IsEmpty(Scheme(ProjectiveSpace(P2P3L), discs));
printf "Verified the statement for the branch conics.\n\n";

printf "=========================================================================\n\n";

printf "Hyperelliptic curves of genus 3\n\n";

// Hyperelliptic genus 3 curves

// For IsHyperelliptic, we need to work over an absolute number field.
LA := AbsoluteField(L);
flag, iso := IsIsomorphic(L, LA); assert flag;
SLA<A1,A2,A3,B1,B2,B3,C> := BaseChange(S, iso);
LAi := Roots(Polynomial([1,0,1]), LA)[1,1];
LAs := Roots(Polynomial([-2,0,1]), LA)[1,1];

// Curves in b_1 +- b_2 +- b_3 = 0. It suffices to consider one hyperplane.
time // ~10 seconds
curves := [Curve(c) : c in IrreducibleComponents(Scheme(SLA, B1 + B2 + B3))];
assert #curves eq 2;
flag, H1 := IsHyperelliptic(curves[1]); assert flag;
flag, H2 := IsHyperelliptic(curves[2]); assert flag;
assert IsIsomorphic(H1, H2) and
       IsIsomorphic(H1, HyperellipticCurve(Polynomial([LA| 1,0,0,0,14,0,0,0,1])));
printf "Verified isomorphism with y² = x⁸ + 14x⁴ + 1.\n\n";

// Curves in a_1 + s*i*a_2 + a_3 + b_2 = 0 (mod Aut)
curves := [Curve(c) : c in IrreducibleComponents(Scheme(SLA, A1 + LAi*LAs*A2 + A3 + B2))];
assert #curves eq 2;
flag, H1 := IsHyperelliptic(curves[1]); assert flag;
flag, H2 := IsHyperelliptic(curves[2]); assert flag;
assert IsIsomorphic(H1, H2) and
       IsIsomorphic(H1, HyperellipticCurve(Polynomial([LA| 17,32,36,64,86,32,4,0,1])));
printf "Verified isomorphism with y² = x⁸ + 4x⁶ + 32x⁵ + 86x⁴ + 36x³ + 32x + 17.\n\n";

printf "=========================================================================\n\n";
